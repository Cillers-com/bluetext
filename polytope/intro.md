# Polytope Documentation Reference

This file contains comprehensive documentation about Polytope, a job runner platform that uses computational graphs based on steps and modules.

Do not try to test the functionality you generate. You don't know enough about how Polytope works to be able to do that in a reliable way. 

When adding a Polytope module for which there is a Blueprint, always use the MCP server to fetch the appropriate blueprint resource. Use the `access_mcp_resource` tool with the server name `bluetext` and the URI `bluetext://blueprints/<blueprint-id>` where `<blueprint-id>` is the specific blueprint you need.

## Core Concepts

### Jobs and Steps
- A **job** is a computational graph based on one or more **steps** arranged in any configuration
- Each step runs a **module** which executes code against Polytope's runner API
- Modules can spawn containers, save datasets, create services, and perform other actions

### Modules
- Modules are the core building blocks of Polytope
- Each step runs a module that interfaces with Polytope's runner API
- Polytope provides a set of built-in modules for common use cases
- Custom modules can be defined using the same interface
- Modules typically accept parameter input conforming to specified types
- Modules can run code snippets directly or wrap other modules

### Templates
- Templates specify full jobs
- Define what steps to run for easy reuse
- Specified using TemplateSpec data type

### Configuration Files
- Modules, templates, and triggers are defined in Polytope files
- Supported formats: `polytope.yml`, `polytope.json`, or `polytope.edn`
- Typically a `polytope.yml` file is placed at the repo root.

### Other Key Concepts
- **Containers**: Docker containers spawned by steps, with replication and autoscaling support
- **Datasets**: Versioned data that can be used as step inputs/outputs
- **Services**: Expose container ports for interaction (localhost for CLI, autogenerated URLs for web service)
- **Values**: Built-in key-value store for steps to read/write
- **Volumes**: Share data between containers or persist data across job runs
- **Triggers**: Run jobs on schedule or following specific events
- **Projects**: Work organization unit in web service, can be owned by users or organizations

## polytope.yml file
The contents of the polytope.yml file must follow the schema `PolytopeFile` from `data_types_yaml_specification.yml` (henceforth: "the definitions file").

The Polytope file has the top-level keys `modules` and `templates`:
- `modules` is a list of module declarations. Modules are encapsulated, reusable snippets of code that take a (possibly empty) set of arguments, and either call another module, or run a snippet of code. Typically modules perform some simple task, like running a container.
- `templates` is a list of template declarations. Each template declaration is a list of module calls. Possibly with ordering dependencies. Templates can also take arguments.

### `modules`
`modules` holds a list of module specs. These specs must adhere to the `ModuleSpec` type in the definitions file.

The following keys are supported when defining a module:
- `id`: Uniquely identifies a module. May only contain '0–9', 'a–z', '_', and '-'. Required.
- `ìnfo`: Optional info string about the module.
- `params`: Parameter declarations for the module. When calling the module, the provided args must match this declaration. Explained in detail below. Optional.
- `module`: Defines another module that this module will call. Not compatible with `code`. Required unless `code` is provided.
- `args`: Arguments to pass as parameters to the module referenced via `module`. Must match the parameters declared in that module. Explained in detail below. Required if the module being called has required parameters.
- `code`: Only provided for modules that run code directly. Not compatible with `args` or `module`. Inline code written in Clojure or JavaScript that runs against the module API.

#### Example
```
# Basic module that prints a user-defined message with a default value:
info: Prints a message to the logs.
id: hello-world
params:
- id: message
  info: The message to be printed.
  name: Message
  type: [default, str, Hello world!]
code: '#pt-clj (println (:message params))'

# Module that calls another module:
info: Runs a PostgreSQL container.
id: postgres
params:
- id: image
  info: The Docker image to run.
  name: Image
  type: [default, docker-image, 'public.ecr.aws/docker/library/postgres:16.2']
- id: container-id
  info: The ID to use for the container.
  name: Container ID
  type: [default, str, postgres]
- id: data-volume
  name: Data Volume
  info: The volume (if any) to mount for data.
  type: [maybe, mount-source]
- id: service-id
  info: The ID to use for the service.
  name: Service ID
  type: [default, str, postgres]
- id: env
  info: Environment variables to pass to the server.
  name: Environment variables
  type: [maybe, [env-var]]
- id: cmd
  info: The command to run in the container. If unspecified, runs the PostgreSQL server.
  name: Command
  type: [maybe, [either, str, [str]]]
- id: restart
  info: What policy to apply on restarting containers that fail.
  name: Restart policy
  type: [maybe, {policy: [enum, always, on-failure], max-restarts: [maybe, int]}]
- id: scripts
  info: SQL files to run when initializing the DB.
  name: Scripts
  type: [maybe, [mount-source]]
module: polytope/container
args:
  image: pt.param image
  id: pt.param container-id
  mounts: |-
    pt.clj
    (concat
     (when-let [v (:data-volume params)]
      [{:path "/var/lib/postgresql/data", :source v}])
     (for [s (:scripts params)]
      {:path   "/docker-entrypoint-initdb.d/data-backup.sql"
       :source s}))
  env: pt.param env
  tty: "pt.clj (empty? (:scripts params))"
  restart: pt.param restart
  services:
  - id: pt.param service-id
    ports: [{protocol: tcp, port: 5432}]
```

#### params
Module parameters are declared via the `params` key, which must be a list of `ParamSpec`. If this key is not present, the module has no parameters.

`ParamSpec`s have the following keys:
- `id`: the name of the parameter. Required.
- `type`: a data structure defining the type of the argument. Must follow the param type DSL, explained below. Required.
- `ìnfo`: Optional info string about the param.

##### Example
```
params:
  - id: foo
    type: [default, {foo: str}, {foo: bar}] # has a default value so does not need to be provided
  - id: bar
  - type: [maybe, str] # optional parameter, can be omitted
  - id: env-vars
    type: [env-var] # a list of environment variables - no default or maybe, so must be provided
```

#### args
When a module calls another module, it passes values for parameters via the `args` key.

Values can be supplied in multiple different ways:
- Literal data: e.g. `foo`, `123`. `[false]`, `{foo: bar}` etc.
- References to parameters (as defined in `params`): `pt.param my-param`
- References to values: `pt.value my-value`.  Values are data (typically strings) that have been provided separately by the user. **IMPORTANT** `pt.value` cannot be accessed in a `#pt-js` script. 
- References to secrets: `pt.secret my-secret`. Secrets are sensitive data (typically strings) that have been provided separately by the user. **IMPORTANT** `pt.secret` cannot be accessed in a `#pt-js` script.
- Interpolated strings: strings that contain references to params, values or secrets, e.g. `http://{pt.param domain}:{pt.value port}/foo?api-key={pt.secret my-secret-key}`
- Code: TODO

Arg values can be any data but _MUST_ match the type spec of the corresponding param in the referenced module.

#### Example

**CORRECT**
```yaml
module: the-module-were-calling  # module defined elsewhere, with params matching the args below
args:
    some-string-param: "hello world"      # plain string
    some-complex-param: [foo, {foo: bar}] # plain data
    some-param: pt.value foo              # reference to a value
    some-param-2: pt.secret foo           # reference to a secret
    some-param-3:
        foo: "interpolated string with a value: {pt.value foo}"
        bar: [pt.param bar, pt.secret baz] # data with inline references
```

**WRONG**
```yaml
    some-param: "#pt-js parseInt(pt.value('foo'))"    # This will throw an error since there is no pt.value property or function in a `#pt-js` script. 
```

#### Param type DSL

The param type DSL is how types are defined in Polytope.

Basic types:
- `str`: strings
- `bool`: `true` or `false`
- `int`: integers
- `num`: any number

Compound types:
- `[...]`: list of elements matching a given type (e.g. `[int]`, `[bool]`).
- `{...}`: map of named keys whose values match provided types (e.g. `{foo: int, bar: str}`)
- `[either, ...]`: union type (e.g. `[either, str, int]`, `[either, str, [str], int, {foo: int}]`)
- `[default, $type, $value]`: type with a default value (e.g. `[default, str, "my-default-value"]`)
- `[enum, ...]`: enum type (e.g. `[enum, 1, 2, "foo"]`)
- `[maybe, $type]`: marks a type as optional.
- `[regex, $regex]`: string type constrained to match the given regex.

There are also type aliases for commonly used types:
- `env-var`: equivalent to `{name: str, value: str}`
- `mount-source`: defined as `MountSourceSpec` in the definitions file. Intended for specifying data to be mounted containers. Examples:
  - `{type: host, path: /foo/bar}`: a path on the host machine to mount into the container. If a relative path like `some/folder` is provided, this is relative to the directory of the `polytope.yml` file. If a relative path with a leading `./`path like `./some/other/folder` is provided, it's relative to the current working directory.
  - `{type: string, data: my-string}`: literal string mounted as a file.
  - `{type: volume, scope: project, id: my-volume}`: a named volume. By default gets created if it doesn't already exist. Persisted across jobs ONLY IF `scope: project` is set.
- `service-spec`: a service specification. Must match `ServiceSpec` in the defiitions file. Keys:
  - `id`: the ID of the created service. Required.
  - `ports`: a list of named port mappings. `ServicePortsSpec` in the defiitions file. Each spec has the following keys:
    - `port`: the port on the container side.
    - `protocol`: the protocol being routed.
    - `expose-as`: the port on the host machine to which the port is mapped.

### Templates
`templates` holds a list of template specs. These specs must adhere to the `TemplateSpec` type in the definitions file.

The following keys are supported when defining a template:
- `id`: Uniquely identifies a template. May only contain '0–9', 'a–z', '_', and '-'. Required.
- `info`: Optional info string about the template.
- `params`: Parameter declarations for the template. Works the same way as for modules. Optional.
- `run`: A list of steps to run. Required. Explained below.

#### Steps
Steps may be provided in one of the following ways:

Plain module references, with no arguments:
```yaml
run:
  - my-module
  - polytope/hello-world
```

Or with arguments:
```yaml
run:
  - module: my-module
    args:
      foo: bar
      baz: 123
  - module: polytope/hello-world
    args:
      message: "Hello, world!"
```

By default, steps get their ID from the module ID. If you want to override this, you can specify the `id` key:
```yaml
run:
  - id: hello-world
    module: polytope/hello-world
    args:
      message: "Hello, world!"
  - id: aiya-ambar
    module: polytope/hello-world
    args:
      message: "Aiya Ambar!"
```

Steps run in parallel by default, but sequencing can be enforced by using `run-when`:
```yaml
run:
  - id: hello-world
    module: polytope/container
    args:
      image: ubuntu
      cmd: "echo Hello, world!"
  - id: hello-world
    module: polytope/hello-world
    args:
      message: "Hello world again!"
    run-when:
      after: hello-world # this step will run after the hello-world step, _INCLUDING THE ASSOCIATED CONTAINER_ completes
```


# Instructions to follow when generating code that should run on Polytope

## Consice template section
Make the template section of the polytope.yml file as short as possible. Define modules under the modules section or use pre-existing Polytope modules and refer to them from the template run section.

Keep names simple, and don't set other ids in templates unless you have multiple calls to the same module.

Don't needlessly add template params. The default params on the module should be sufficient for most use cases.

## Adding modules and templates
Whenever adding a module or template to the polytope.yml file, first check if there is a Blueprint for this type of module or template. **IMPORTANT: If the Blueprint includes a `boilerplate.md` file, use the `boilerplate` module to generate the initial code for the module or template!**

Module code should be placed under the `./modules/<module-id>` directory.

## Give modules sensible parameters
Try to provide default values for all parameters in the modules you write. Prefer parameters to 'hard-coding' values in the module, especially if they're repeated or can be expected to change.

## No hard coded property values that the user may want to change between deployment environments
In the polytope.yml file, all values that may change between deployment environment should be dynamically loaded from Polytope secrets and values, e.g. all ports, hostnames, and protocols should be stored as Polytope values and all usernames, passwords and api keys should be stored as Polytope secrets. All property values specified in a ServiceSpec or EnvVarSpec should be referenced as Polytope values, e.g. port: pt.value api_port. Ensure that no property value inside of a ServiceSpec of EnvVarSpec is hard coded.

## Correct type for args
Make sure that modules get the correct type of parameters. When a module expects an int but gets a str, it will fail. Error example: Must be an integer (got "8079"). Polytope values and secrets are always of type str.


## Hostnames
The hostnames that web apps need, must be based on Polytope values, so they can be dynamically set to different values in deployment different environments.

The Polytope service hostnames that are accessible internally within a template are not available to a web browser or any other software running outside of Polytope.

## In templates, don't provide `after` unless steps must wait for another step to complete
**CRITICAL**: In a Polytope template that defines a stack of services, NEVER use `run-when: after` for services!

Services that use `polytope/container` BLOCK until the container shuts down. Using `after` would mean waiting forever!

❌ **WRONG**:
```yaml
run:
  - redpanda
  - module: api
    run-when:
      after: redpanda  # This will wait forever!
```

✅ **CORRECT**:
```yaml
run:
  - redpanda
  - api  # Runs concurrently!
  - web-app  # All services start together
```

All services must be fault-tolerant and handle connection failures gracefully with retries.

## Code that depends on other services, must assume those services may be down
All code that you generate must be resilient to services that the code depends on may be down, such as databases and message queues. These services may not have started yet, they could be temporary out of order, or they could be restarting. 

## Executables
Ensure that all files to be executed are executable.

## ALWAYS use persistent volumes for stateful services
**CRITICAL**: Services like databases, message queues, and caches MUST have persistent volumes or data will be lost on restart.

❌ **WRONG**:
```yaml
templates:
  - id: stack
    run:
      - polytope/redpanda  # NO! Data will be lost!
```

✅ **CORRECT**:
```yaml
modules:
  - id: redpanda
    module: polytope/redpanda
    args:
      data-volume:
        type: volume
        scope: project # ALWAYS use project scope for persistent data! The default scope is job, which is ephemeral.
        id: redpanda-data

templates:
  - id: stack
    run:
      - redpanda  # Uses your wrapper with volume
```

## Module inheritance
Try to stick to the built-in modules. If there's no suitable module for what you're trying to achieve, create a custom module that calls `polytope/container`.

## Polytope file layout
Prefer creating modules for the different execution units of your application, e.g. web-app, api, redpanda, etc. Avoid putting module data directly in templates if it makes sense to be able to run the module directly.

## Write stuff to be run in Polytope
Want to create a test script? Put it in a separate directory and create a module for it (is it a shell script? just use `polytope/container` with `image: alpine` or whatever). Ditto for any other runnable units of code!

If you have different commands in your app, create corresponding run scripts in `bin/` and create a specialized module, e.g.:
```yaml
modules:
  - id: api
    module: polytope/python
    params:
      - id: cmd
        type: [default, str, "bin/run"]
    args:
      id: my-app
      image: python:3.13-slim
      code: { type: host, path: ./modules/api }
      cmd: pt.param cmd

  - id: api-test
    module: api
    params: {cmd: "bin/test"}

  - id: api-ipython
    module: api
    params: {cmd: "bin/ipython"}
```

# Polytope Data Types And Specification
```yaml
$schema: https://json-schema.org/draft/2020-12/schema
$id: https://example.com/schemas/polytope-data-types
title: Polytope Data Types
description: Comprehensive schema for all Polytope data types based on the provided documentation.
type: object
additionalProperties: true
definitions:
  Code:
    title: Code
    type: string
    description: Representation of code, prefixed with language identifier or raw Clojure form.
    oneOf:
      - pattern: "^#(pt-js|pt-py|pt-clj)\\s.*$"
      - type: string
  CronExpr:
    title: CronExpr
    type: string
    description: Cron schedule expression, e.g., '15 3 * * *'.
  DatasetRef:
    title: DatasetRef
    type: string
    description: Reference to a dataset, e.g., 'my-dataset' or 'my-org/my-project>dataset:my-dataset'.
    pattern: "^[a-z0-9_-]+(>[a-z0-9_-]+>dataset:[a-z0-9_-]+)?$"
  EnvVarSpec:
    title: EnvVarSpec
    type: object
    properties:
      name:
        type: string
      value:
        oneOf:
          - type: string
          - type: string
          - type: boolean
          - type: integer
    required:
      - name
    additionalProperties: false
  Id:
    title: Id
    type: string
    pattern: "^[a-z0-9_-]+$"
  ModuleRef:
    title: ModuleRef
    type: string
    pattern: "^[a-z0-9_-]+/[a-z0-9_-]+(@[a-zA-Z0-9_-]+)?(:[a-z0-9_-/]+)?(![a-z0-9_-]+)?$"
  ModuleSpec:
    title: ModuleSpec
    type: object
    properties:
      api-version:
        type: string
      args:
        type: object
        additionalProperties: true
        patternProperties:
          "^[a-z0-9_-]+$": {}
      code:
        $ref: "#/definitions/Code"
      default?:
        type: boolean
      id:
        $ref: "#/definitions/Id"
      info:
        type: string
      module:
        $ref: "#/definitions/ModuleRef"
      params:
        type: array
        items:
          type: object
          properties:
            id:
              $ref: "#/definitions/Id"
            info:
              type: string
            name:
              type: string
            type:
              description: Parameter data type format.
          required:
            - id
            - type
          additionalProperties: false
    oneOf:
      - required: [code]
      - required: [module]
    required:
      - id
    additionalProperties: false
  MountSourceSpec:
    title: MountSourceSpec
    oneOf:
      - type: object
        properties:
          dataset:
            oneOf:
              - $ref: "#/definitions/DatasetRef"
              - $ref: "#/definitions/Uid"
          path:
            type: string
          type:
            type: string
            const: "dataset"
          version:
            type: integer
        required:
          - dataset
          - type
        additionalProperties: false
      - type: object
        properties:
          path:
            type: string
          type:
            type: string
            const: "host"
        required:
          - path
          - type
        additionalProperties: false
      - type: object
        properties:
          path:
            type: string
          repo:
            oneOf:
              - $ref: "#/definitions/RepoRef"
              - $ref: "#/definitions/Uid"
          revision:
            type: string
          type:
            type: string
            const: "repo"
        required:
          - type
        additionalProperties: false
      - type: object
        properties:
          data:
            type: string
          type:
            type: string
            const: "string"
        required:
          - data
          - type
        additionalProperties: false
      - type: object
        properties:
          create:
            type: string
            enum: ["never", "when-missing", "always"]
          id:
            $ref: "#/definitions/Id"
          scope:
            type: string
            enum: ["project", "job"]
          source:
            $ref: "#/definitions/MountSourceSpec"
          type:
            type: string
            const: "volume"
        required:
          - type
        additionalProperties: false
  PolytopeFile:
    title: PolytopeFile
    type: object
    properties:
      modules:
        type: array
        items:
          $ref: "#/definitions/ModuleSpec"
      templates:
        type: array
        items:
          $ref: "#/definitions/TemplateSpec"
    additionalProperties: false
  RepoRef:
    title: RepoRef
    type: string
    pattern: "^[a-z0-9_-]+/[a-z0-9_-]+(/[a-z0-9_-]+)?$"
  ServicePortsSpec:
    title: ServicePortsSpec
    oneOf:
      - type: object  # Single port
        properties:
          expose-as:
            type: integer
          internal:
            type: boolean
          label:
            $ref: "#/definitions/Id"
          port:
            type: integer
          protocol:
            type: string
            enum: ["tcp", "udp", "http", "https"]
        required:
          - port
          - protocol
        additionalProperties: false
      - type: object  # Port range
        properties:
          expose-as:
            type: string
          internal:
            type: boolean
          label:
            $ref: "#/definitions/Id"
          protocol:
            type: string
            enum: ["tcp", "udp", "http", "https"]
          range:
            type: string
        required:
          - protocol
          - range
        additionalProperties: false
  TemplateSpec:
    title: TemplateSpec
    type: object
    properties:
      id:
        $ref: "#/definitions/Id"
      info:
        type: string
      run:
        type: array
        items:
          oneOf:
            - type: object
              properties:
                args:
                  type: object
                  additionalProperties: true
                  patternProperties:
                    "^[a-z0-9_-]+$": {}
                id:
                  $ref: "#/definitions/Id"
                module:
                  $ref: "#/definitions/ModuleRef"
                run-when:
                  type: object
                  properties:
                    after:
                      type: string
                    after-condition:
                      type: string
                      enum: ["success", "always", "failed"]
                  additionalProperties: false
              required:
                - module
              additionalProperties: false
            - $ref: "#/definitions/ModuleRef"
    required:
      - id
      - run
    additionalProperties: false
  Uid:
    title: Uid
    type: string
    pattern: "^[0-9a-f]{16}$"

```

# Polytope Standard Modules

This file contains module definitions for some built-in Polytope modules. Use these if you can.

# polytope/redpanda

```yml
info: Runs a single Redpanda node in dev mode.
id: redpanda
params:
- id: image
  info: The container image to use.
  name: Container Image
  type: [default, str, 'docker.redpanda.com/redpandadata/redpanda:v23.3.11']
- id: data-volume
  info: Volume to use for data.
  name: Data Volume
  type: [maybe, mount-source]
- id: log-level
  info: The default log level.
  name: Log level
  type:
  - default
  - [enum, trace, debug, info, warn, error]
  - info
- id: restart
  info: Restart policy for the containers.
  name: Restart policy
  type:
  - default
  - policy: [enum, always, on-failure]
    max-restarts: [maybe, int]
  - {policy: always, max-restarts: null}
module: polytope/container
args:
  id: redpanda
  image: pt.param image
  restart: pt.param restart
  cmd:
  - redpanda
  - start
  - --kafka-addr=0.0.0.0:9092
  - --advertise-kafka-addr=redpanda:9092
  - --pandaproxy-addr=0.0.0.0:8082
  - --advertise-pandaproxy-addr=redpanda:8082
  - --rpc-addr=0.0.0.0:33145
  - --advertise-rpc-addr=redpanda:33145
  - --schema-registry-addr=0.0.0.0:8081
  - --mode=dev-container
  - --smp=1
  - "--default-log-level={pt.param log-level}"
  mounts: |-
    #pt-clj (when-let [v (:data-volume params)]
      [{:path "/var/lib/redpanda/data", :source v}])
  services:
  - id: redpanda
    ports:
    - {port: 9092, protocol: tcp, label: kafka}
    - {port: 8082, protocol: http, label: pandaproxy}
    - {port: 8081, protocol: http, label: schema-registry}
    - {port: 9644, protocol: http, label: admin-api}
    - {port: 33145, protocol: tcp, label: rpc}
```

# polytope/redpanda!console

```yml
info: Runs the Redpanda console.
id: console
params:
- id: image
  info: The image to use.
  name: Image
  type: [default, str, 'docker.redpanda.com/redpandadata/console:v2.4.5']
- id: container-id
  info: The ID to give the spawned container.
  name: Container ID
  type: [default, str, redpanda-console]
- id: brokers
  info: List of host-port pairs to use to connect to the Kafka/Redpanda cluster.
  name: Brokers
  type:
  - default
  - - {host: str, port: int}
  - - {host: redpanda, port: 9092}
- id: schema-registry-url
  info: Schema Registry to connect to.
  name: Schema Registry URL
  type: [maybe, str]
- id: admin-url
  info: Redpanda admin URL to connect to.
  name: Redpanda admin URL
  type: [maybe, str]
- id: log-level
  info: The log level.
  name: Log level
  type:
  - default
  - [enum, debug, info, warn, error, fatal]
  - info
- id: port
  info: The console HTTP port.
  name: HTTP Port
  type: [default, int, 8079]
- id: restart
  info: Restart policy for the container.
  name: Restart policy
  type:
  - default
  - policy: [enum, always, on-failure]
    max-restarts: [maybe, int]
  - {policy: always, max-restarts: null}
module: polytope/container
args:
  image: pt.param image
  id: pt.param container-id
  env:
  - {name: CONFIG_FILEPATH, value: /etc/redpanda-console-config.yaml}
  mounts:
  - path: /etc/redpanda-console-config.yaml
    source:
      type: string
      data: |-
        #pt-clj (let [brokers (clojure.string/join
                       (map
                       (fn
                       [{:keys [host port]}]
                       (str host \: port))
                       (:brokers params)))]
          (str
           "kafka:\n"
           "  brokers: [\""
           brokers
           "\"]\n"
           "server:\n"
           "  listenPort: "
           (:port params)
           "\n"
           (when-let [url (:schema-registry-url params)]
            (str
             "  schemaRegistry:\n"
             "    enabled: true\n"
             "    urls: [\""
             url
             "\"]\n"))
           (when-let [url (:admin-url params)]
            (str
             "redpanda:\n"
             "  adminApi:\n"
             "    enabled: true\n"
             "    urls: [\""
             url
             "\"]\n"))
           "logger:\n"
           "  level: "
           (:log-level params)
           "\n"))
  restart: pt.param restart
  services:
  - id: redpanda-console
    ports:
    - {port: pt.param port, protocol: http}

```

# polytope/redpanda!connect

```yml
info: Runs Redpanda connect.
id: connect
params:
- id: image
  info: The image to use.
  name: Image
  type: [default, str, docker.redpanda.com/redpandadata/connect]
- id: container-id
  info: The ID to give the spawned container.
  name: Container ID
  type: [default, str, redpanda-connect]
- {id: config-file, info: Redpanda connect config file., name: Config file, type: mount-source}
- id: restart
  info: Restart policy for the container.
  name: Restart policy
  type:
  - default
  - policy: [enum, always, on-failure]
    max-restarts: [maybe, int]
  - {policy: always, max-restarts: null}
- id: port
  info: The console HTTP port.
  name: HTTP Port
  type: [default, int, 4195]
module: polytope/container
args:
  image: pt.param image
  id: pt.param container-id
  mounts:
  - {path: /connect.yaml, source: pt.param config-file}
  restart: pt.param restart
  services:
  - id: redpanda-connect
    ports:
    - {port: pt.param port, protocol: http}
```

# polytope/postgres

```yml
info: Runs a PostgreSQL container.
id: postgres
params:
- id: image
  info: The Docker image to run.
  name: Image
  type: [default, docker-image, 'public.ecr.aws/docker/library/postgres:16.2']
- id: container-id
  info: The ID to use for the container.
  name: Container ID
  type: [default, str, postgres]
- id: data-volume
  name: Data Volume
  info: The volume (if any) to mount for data.
  type: [maybe, mount-source]
- id: service-id
  info: The ID to use for the service.
  name: Service ID
  type: [default, str, postgres]
- id: env
  info: Environment variables to pass to the server.
  name: Environment variables
  type:
  - maybe
  - [env-var]
- id: cmd
  info: The command to run in the container. If unspecified, runs the PostgreSQL server.
  name: Command
  type:
  - maybe
  - - either
    - str
    - - [maybe, str]
- id: restart
  info: What policy to apply on restarting containers that fail.
  name: Restart policy
  type:
  - maybe
  - policy: [enum, always, on-failure]
    max-restarts: [maybe, int]
- id: scripts
  info: SQL files to run when initializing the DB.
  name: Scripts
  type:
  - maybe
  - [mount-source]
module: polytope/container
args:
  image: pt.param image
  id: pt.param container-id
  mounts: |-
    #pt-clj (concat
     (when-let [v (:data-volume params)]
      [{:path "/var/lib/postgresql/data", :source v}])
     (for [s (:scripts params)]
      {:path   "/docker-entrypoint-initdb.d/data-backup.sql"
       :source s}))
  env: pt.param env
  tty: '#pt-clj (empty? (:scripts params))'
  restart: pt.param restart
  services:
  - id: pt.param service-id
    ports:
    - {protocol: tcp, port: 5432}
```

# polytope/postgres!simple

```yml
info: Runs a PostgreSQL container with minimal configuration.
id: simple
params:
- id: image
  info: The Docker image to run.
  name: Image
  type: [default, docker-image, 'postgres:15.4']
- id: scripts
  info: SQL files to run when initializing the DB.
  name: Scripts
  type:
  - maybe
  - [mount-source]
- id: data-volume
  name: Data Volume
  info: The volume (if any) to mount for data.
  type: [maybe, mount-source]
- id: restart
  info: What policy to apply on restarting containers that fail.
  name: Restart policy
  type:
  - maybe
  - policy: [enum, always, on-failure]
    max-restarts: [maybe, int]
module: polytope/container
args:
  image: pt.param image
  id: pt.param id
  mounts: |-
    #pt-clj (concat
     (when-let [v (:data-volume params)]
      [{:path "/var/lib/postgresql/data", :source v}])
     (for [s (:scripts params)]
      {:path   "/docker-entrypoint-initdb.d/data-backup.sql"
       :source s}))
  env:
  - {name: POSTGRES_HOST_AUTH_METHOD, value: trust}
  tty: '#pt-clj (empty? (:scripts params))'
  restart: pt.param restart
  services:
  - id: postgres
    ports:
    - {protocol: tcp, port: 5432}
```

# polytope/python

```yml
info: Runs a Python container.
id: python
params:
- id: image
  info: The container image to use.
  name: Image
  type: [default, str, 'public.ecr.aws/docker/library/python:3.12.2-slim-bookworm']
- id: code
  info: Optional source code directory to mount into the container.
  name: Code
  type: [maybe, mount-source]
- id: cmd
  info: The command to run. Runs a Python shell if left blank.
  name: Command
  type:
  - maybe
  - - either
    - str
    - [str]
- id: env
  info: Environment variables for the container.
  name: Environment variables
  type:
  - maybe
  - - [maybe, env-var]
- id: requirements
  info: Optional requirements.txt file to install before running the command.
  name: Requirements file
  type: [maybe, mount-source]
- id: services
  info: Ports in the container to expose as services.
  name: Services
  type:
  - maybe
  - [service-spec]
- id: id
  info: The container's ID/name.
  name: ID
  type: [maybe, id]
- id: mounts
  info: Additional files or directories to mount into the container.
  name: Mounts
  type:
  - maybe
  - - - maybe
      - {source: mount-source, path: absolute-path}
- id: restart
  info: What policy to apply on restarting containers that fail.
  name: Restart policy
  type:
  - maybe
  - policy: [enum, always, on-failure]
    max-restarts: [maybe, int]
module: polytope/container
args:
  cmd: |-
    #pt-clj (if (:requirements params)
      (if (or
           (nil? (:cmd params))
           (string? (:cmd params)))
        (str
         "sh -c 'pip install -r /requirements.txt; "
         (or (:cmd params) "python")
         "'")
        (str
         "sh -c 'pip install -r /requirements.txt; "
         (str/join " " (:cmd params))
         "'"))
      (:cmd params))
  env: pt.param env
  services: pt.param services
  id: pt.param id
  image: pt.param image
  mounts: |-
    #pt-clj (vec
     (concat
     (when-let [code (:code params)]
      [{:path "/app", :source code}])
     (when-let [reqs (:requirements params)]
      [{:path "/requirements.txt", :source reqs}])
     (:mounts params)))
  restart: pt.param restart
  workdir: /app
```

# polytope/python!simple

```yml
info: Runs a Python container with minimal configuration.
id: simple
params:
- id: code
  info: Optional source code directory to mount into the container.
  name: Code
  type: [maybe, mount-source]
- id: cmd
  info: The command to run. Runs a Python shell if left blank.
  name: Command
  type: [maybe, str]
- id: env
  info: Environment variables for the container.
  name: Environment variables
  type:
  - maybe
  - [env-var]
- id: services
  info: Ports in the container to expose as services.
  name: Services
  type:
  - maybe
  - - {id: str, port: int}
module: polytope/container
args:
  cmd: pt.param cmd
  env: pt.param env
  services: |-
    #pt-clj (map
     (fn
     [{:keys [id port]}]
     {:id    id
     :ports [{:port port, :protocol :http}]})
     (:services params))
  image: python:3.11
  update-image: false
  mounts: |-
    #pt-clj (vec
     (concat
     (when-let [code (:code params)]
      [{:path "/app", :source code}])
     (when-let [reqs (:requirements params)]
      [{:path "/requirements", :source reqs}])))
  workdir: /app
```

# polytope/container

```yml
info: Runs a Docker container.
id: container
params:
- {id: image, info: The Docker image to run., name: Image, type: docker-image}
- id: id
  info: The container's ID/name.
  name: ID
  type: [maybe, id]
- id: cmd
  info: The command to run in the container.
  name: Command
  type:
  - maybe
  - - either
    - str
    - - [maybe, str]
- id: mounts
  info: Code or files to mount into the container.
  name: Mounts
  type:
  - maybe
  - - - maybe
      - {source: mount-source, path: absolute-path}
- id: env
  info: Environment variables for the container.
  name: Environment variables
  type:
  - maybe
  - - [maybe, env-var]
- id: workdir
  info: The container's working directory.
  name: Working directory
  type: [maybe, absolute-path]
- id: entrypoint
  info: The container's entrypoint.
  name: Entrypoint
  type:
  - maybe
  - - either
    - str
    - - [maybe, str]
- id: no-stdin
  info: Whether to keep the container's stdin closed.
  name: Non-interactive
  type: [default, bool, false]
- id: tty
  info: Whether to allocate a pseudo-TTY for the container.
  name: TTY
  type: [default, bool, true]
- id: services
  info: Ports in the container to expose as services.
  name: Services
  type:
  - maybe
  - [service-spec]
- id: datasets
  info: Paths in the container to store as datasets upon termination.
  name: Datasets
  type:
  - maybe
  - - {path: absolute-path, sink: dataset-sink}
- id: user
  info: The user (name or UID) to run commands in the container as.
  name: User
  type:
  - maybe
  - [either, int, str]
- id: restart
  info: What policy to apply on restarting containers that fail.
  name: Restart policy
  type:
  - maybe
  - policy:
    - maybe
    - [enum, never, always, on-failure]
    max-restarts: [maybe, int]
- id: scaling
  info: How many replicas to create.
  name: Replicas
  type: [maybe, int]
- id: update-image
  info: Image update policy.
  name: Update image
  type: [default, bool, false]
- id: instance-type
  info: The instance type to run the container on.
  name: Instance type
  type: [maybe, instance-type]
- id: resources
  info: The resources to allocate for the container.
  name: Resources
  type:
  - maybe
  - cpu:
      request: [maybe, num]
      limit: [maybe, num]
    memory:
      request: [maybe, data-size]
      limit: [maybe, data-size]
code: |-
  #pt-clj (let [spec (merge
              (dissoc params :services :datasets)
              (when-let [replicas (:scaling params)]
               {:scaling {:replicas replicas, :type "manual"}}))
        id   (pt/spawn spec)]
    (pt/await-started
     {:ref id, :type "deployment"})
    (doseq [service (:services params)]
      (pt/open-service service))
    (let [exit-code (pt/await-done
                     {:ref id, :type "deployment"})]
      (when (not= 0 exit-code)
        (pt/fail
         "The container exited with a nonzero exit code."
         {:exit-code exit-code})))
    (doseq [{:keys [path sink]} (:datasets params)]
      (pt/store-dataset
       {:container-id id
       :path         path
       :type         "container-path"}
       sink)))
```

# polytope/node

```yml
info: Runs a Node.js container.
id: node
params:
- id: image
  info: The container image to use.
  name: Image
  type: [default, str, 'public.ecr.aws/docker/library/node:21.7.0-slim']
- id: code
  info: Optional source code directory to mount into the container.
  name: Code
  type: [maybe, mount-source]
- id: cmd
  info: The command to run. Runs a Node shell if left blank.
  name: Command
  type:
  - maybe
  - - either
    - str
    - [str]
- id: env
  info: Environment variables for the container.
  name: Environment variables
  type:
  - maybe
  - - name: str
      value: [either, str, int, bool]
- id: id
  info: The container's ID/name.
  name: ID
  type: [maybe, id]
- id: package
  info: Optional package.json file to install before running the command.
  name: Package file
  type: [maybe, mount-source]
- id: mounts
  info: Additional files or directories to mount into the container.
  name: Mounts
  type:
  - maybe
  - - - maybe
      - {source: mount-source, path: absolute-path}
- id: restart
  info: What policy to apply on restarting containers that fail.
  name: Restart policy
  type:
  - maybe
  - policy: [enum, always, on-failure]
    max-restarts: [maybe, int]
- id: services
  info: Ports in the container to expose as services.
  name: Services
  type:
  - maybe
  - [service-spec]
module: polytope/container
args:
  cmd: |-
    #pt-clj (if (:package params)
      (if (or
           (nil? (:cmd params))
           (string? (:cmd params)))
        (str
         "sh -c 'npm install /package.json; "
         (or (:cmd params) "node")
         "'")
        (str
         "sh -c 'npm install /package.json; "
         (str/join " " (:cmd params))
         "'"))
      (:cmd params))
  env: pt.param env
  services: pt.param services
  image: pt.param image
  id: pt.param id
  mounts: |-
    #pt-clj (vec
     (concat
     (when-let [code (:code params)]
      [{:path "/app", :source code}])
     (when-let [reqs (:package params)]
      [{:path "/package.json", :source reqs}])
     (:mounts params)))
  restart: pt.param restart
  workdir: /app
```

# Documentation for Polytope secrets and values

Polytope supports setting and reading secrets and values. 

## Secrets and values are set using the polytope CLI as follows.  

### pt secret set --help          
Sets the value of a secret.

USAGE
  $ pt secrets set [<secret-id>] [<data>] [optional flags]

DESCRIPTION
--  Sets the value of a secret.
  Overwrites the value if it already exists.
  
  A specification in YAML/JSON/EDN format must be provided, using one of the
  following methods:
   - stdin (in combination with the `--stdin` flag)
   - a file (in combination with the `--file` flag)

COMMAND OPTIONS
  -c, --context=<context>          Runs as a specific user against a specific Polytope instance.
  -f, --file=<path>                Reads a secret specification from a YAML/JSON/EDN file.
  -o, --output=<(yaml|json|edn)>   Selects output format [default: yaml].
      --pretty                     Pretty-prints output when supported [default: true].
  -r, --raw                        If the data is a string, number, or boolean, prints it as a raw string.
      --stdin                      If selected, reads a secret specification in YAML/JSON/EDN format from stdin.

GLOBAL OPTIONS
      --config-file=<path>   CLI config file path [default: ~/.config/polytope/config.yaml].
  -h, --help                 Prints help for the command.
      --log-file=<path>      Log printing file path [default: ~/.local/state/polytope/cli.log].
  -v, --verbose              Enables log printing in terminal. Raises level of detail in log file.
      --version              Prints the current CLI version.

### pt value set --help.
Sets the value of a value.

USAGE
  $ pt values set [<value-id>] [<data>] [optional flags]

DESCRIPTION
  Sets the value of a value.
  Overwrites the value if it already exists.
  
  A specification in YAML/JSON/EDN format must be provided, using one of the
  following methods:
   - stdin (in combination with the `--stdin` flag)
   - a file (in combination with the `--file` flag)

COMMAND OPTIONS
  -c, --context=<context>          Runs as a specific user against a specific Polytope instance.
  -f, --file=<path>                Reads a value specification from a YAML/JSON/EDN file.
  -o, --output=<(yaml|json|edn)>   Selects output format [default: yaml].
      --pretty                     Pretty-prints output when supported [default: true].
  -r, --raw                        If the data is a string, number, or boolean, prints it as a raw string.
      --stdin                      If selected, reads a value specification in YAML/JSON/EDN format from stdin.

GLOBAL OPTIONS
      --config-file=<path>   CLI config file path [default: ~/.config/polytope/config.yaml].
  -h, --help                 Prints help for the command.
      --log-file=<path>      Log printing file path [default: ~/.local/state/polytope/cli.log].
  -v, --verbose              Enables log printing in terminal. Raises level of detail in log file.
      --version              Prints the current CLI version.


## Secrets and values are dereferenced in the polytope.yml file as follows

The value of a map pair can be specified as the data for a value or a secret. E.g. 

modules: 
    ...

    - id: couchbase
      args:
        ... 
        env:
            ...
            - { name: COUCHBASE_HOST, value: pt.value couchbase_host }
            - { name: COUCHBASE_USERNAME, value: pt.secret couchbase_username }
            - { name: COUCHBASE_PASSWORD, value: pt.secret couchbase_password }

    - id: web-app
      args:
        ...
        env: 
            ...
            - { name: API_PROTOCOL, value: pt.value api_protocol }
            - { name: API_HOST, value: pt.value api_external_host }
            - { name: API_PORT, value: pt.value api_port }

  - id: redpanda-console
    args:
      ...
      env: [{ name: REDPANDA_BROKERS, value: "{pt.value redpanda-host}:{pt.value redpanda-port}" }]

        
## Sample executable file with default values and secrets
Store all default values and secrets in an executable file `.values_and_secrets.defaults.sh`. This file should contain 
set commands for all values and secrets that are referenced in the polytope.yml file with default values. 

This enables the user to execute that file to set all values and secrets when initializing the project on a new machine. 

Make sure the .secrets_and_values.sh file pattern is added to the .gitignore file, so the user can store real secrets and local variables that should not be checked in in that file.

## Polytope values and secrets are stored as strings
When dereferencing a Polytope value or secret in the `polytope.yml` file, the dereferenced type will always be a string, even if it was set to be an int. 

So, when dereferencing a value or a secret in `polytope.yml` you need to use the following best-practice workaround: 
Create two modules: one top-level module and a base-level module. 

### Top-level module
The top-level module uses the base-level module as `module`. It dereferences the needed Polytope values and passes them on to the base module as args. 

### Base-level module
This base-level module does everything else needed for the module to run properly. It exposes as params the values needed to convert from strings to other types, such as ints. It then converts those params to the appropriate types in the args values.

### Example

✅ **CORRECT**:
```yaml
templates: 
  - id: stack
    run:
      - redpanda-console

modules: 
  - id: redpanda-console
    info: Redpanda Console web UI
    module: redpanda-console-base
    args:
      port: pt.values redpanda_console_port
      redpanda-port: pt.values redpanda_port

  - id: redpanda-console-base
    info: Redpanda Console web UI
    module: polytope/redpanda!console
    params:
      - id: port
        type: [default, str, "8080"]
      - id: redpanda-port
        type: [default, str, "9092"]
    args:
      brokers:
        - host: pt.value redpanda_host
          port: "#pt-js parseInt(params['redpandaPort'])"
      admin-url: "http://{pt.value redpanda_host}:9644"
      port: "#pt-js parseInt(params['port'])"
```

Notice that the top-level module specifies the base-level module as it's parent module. 

Notice the the base-level module dereferences the redpanda_host value since it's ok as a str. 

Both of the port args are required by the polytope/redpanda!console to be of type int. 

Notice that the conversion happens in a `#pt-js` script, in which the module params are accessible in the `params` map. And notice that param keys are converted from snakecase and dashcase to camelcase. 

**IMPORTANT `pt.value` is not available within `#pt-js` scripts, only `params`.**

❌ **WRONG**:
```yaml
  expose-as: "#pt-js parseInt(pt.value('api_port'))" # There is no `value` property in the pt object within a #pt-js script.
```

❌ **WRONG**:
```yaml
modules:
  - id: api
    services:
      - id: api
        ports:
          - port: 8888
            protocol: http
            expose-as: "#pt-js parseInt(params['api_port'])" # This will throw an error becuase there is no param 'api_port' specified for this module.
```

✅ **CORRECT**:
```yaml
modules:
  - id: api
    module: api-base
    args:
      - id: port
        value: pt.value port 

  - id: api-base
    params:
      - id: port
        type: [default, str, "4000"]
    env:
      - id: port
        value: 8888
    services:
      - id: api-base
        ports:
          - port: 8888
            protocol: http
            expose-as: "#pt-js parseInt(params['port'])"
```
