# Polytope Documentation Reference

This file contains comprehensive documentation about Polytope, a job runner platform that uses computational graphs based on steps and modules.

## Core Concepts

### Jobs and Steps
- A **job** is a computational graph based on one or more **steps** arranged in any configuration
- Each step runs a **module** which executes code against Polytope's runner API
- Modules can spawn containers, save datasets, create services, and perform other actions

### Modules
- Modules are the core building blocks of Polytope
- Each step runs a module that interfaces with Polytope's runner API
- Polytope provides a set of built-in modules for common use cases
- Custom modules can be defined using the same interface
- Modules typically accept parameter input conforming to specified types
- Modules can run code snippets directly or wrap other modules

### Templates
- Templates specify full jobs
- Define what steps to run for easy reuse
- Specified using TemplateSpec data type

### Configuration Files
- Modules, templates, and triggers are defined in Polytope files
- Supported formats: `polytope.yml`, `polytope.json`, or `polytope.edn`
- Typically a `polytope.yml` file is placed at the repo root.

### Other Key Concepts
- **Containers**: Docker containers spawned by steps, with replication and autoscaling support
- **Datasets**: Versioned data that can be used as step inputs/outputs
- **Services**: Expose container ports for interaction (localhost for CLI, autogenerated URLs for web service)
- **Values**: Built-in key-value store for steps to read/write
- **Volumes**: Share data between containers or persist data across job runs
- **Triggers**: Run jobs on schedule or following specific events
- **Projects**: Work organization unit in web service, can be owned by users or organizations

## polytope.yml file
The contents of the polytope.yml file must follow the schema `PolytopeFile` from `data_types_yaml_specification.yml` (henceforth: "the definitions file").

The Polytope file has the top-level keys `modules` and `templates`:
- `modules` is a list of module declarations. Modules are encapsulated, reusable snippets of code that take a (possibly empty) set of arguments, and either call another module, or run a snippet of code. Typically modules perform some simple task, like running a container.
- `templates` is a list of template declarations. Each template declaration is a list of module calls. Possibly with ordering dependencies. Templates can also take arguments.

### `modules`
`modules` holds a list of module specs. These specs must adhere to the `ModuleSpec` type in the definitions file.

The following keys are supported when defining a module:
- `id`: Uniquely identifies a module. May only contain '0–9', 'a–z', '_', and '-'. Required.
- `ìnfo`: Optional info string about the module.
- `params`: Parameter declarations for the module. When calling the module, the provided args must match this declaration. Explained in detail below. Optional.
- `module`: Defines another module that this module will call. Not compatible with `code`. Required unless `code` is provided.
- `args`: Arguments to pass as parameters to the module referenced via `module`. Must match the parameters declared in that module. Explained in detail below. Required if the module being called has required parameters.
- `code`: Only provided for modules that run code directly. Not compatible with `args` or `module`. Inline code written in Clojure or JavaScript that runs against the module API.

#### Example
```
# Basic module that prints a user-defined message with a default value:
info: Prints a message to the logs.
id: hello-world
params:
- id: message
  info: The message to be printed.
  name: Message
  type: [default, str, Hello world!]
code: '#pt-clj (println (:message params))'

# Module that calls another module:
info: Runs a PostgreSQL container.
id: postgres
params:
- id: image
  info: The Docker image to run.
  name: Image
  type: [default, docker-image, 'public.ecr.aws/docker/library/postgres:16.2']
- id: container-id
  info: The ID to use for the container.
  name: Container ID
  type: [default, str, postgres]
- id: data-volume
  name: Data Volume
  info: The volume (if any) to mount for data.
  type: [maybe, mount-source]
- id: service-id
  info: The ID to use for the service.
  name: Service ID
  type: [default, str, postgres]
- id: env
  info: Environment variables to pass to the server.
  name: Environment variables
  type: [maybe, [env-var]]
- id: cmd
  info: The command to run in the container. If unspecified, runs the PostgreSQL server.
  name: Command
  type: [maybe, [either, str, [str]]]
- id: restart
  info: What policy to apply on restarting containers that fail.
  name: Restart policy
  type: [maybe, {policy: [enum, always, on-failure], max-restarts: [maybe, int]}]
- id: scripts
  info: SQL files to run when initializing the DB.
  name: Scripts
  type: [maybe, [mount-source]]
module: polytope/container
args:
  image: pt.param image
  id: pt.param container-id
  mounts: |-
    pt.clj
    (concat
     (when-let [v (:data-volume params)]
      [{:path "/var/lib/postgresql/data", :source v}])
     (for [s (:scripts params)]
      {:path   "/docker-entrypoint-initdb.d/data-backup.sql"
       :source s}))
  env: pt.param env
  tty: "pt.clj (empty? (:scripts params))"
  restart: pt.param restart
  services:
  - id: pt.param service-id
    ports: [{protocol: tcp, port: 5432}]
```

#### params
Module parameters are declared via the `params` key, which must be a list of `ParamSpec`. If this key is not present, the module has no parameters.

`ParamSpec`s have the following keys:
- `id`: the name of the parameter. Required.
- `type`: a data structure defining the type of the argument. Must follow the param type DSL, explained below. Required.
- `ìnfo`: Optional info string about the param.

##### Example
```
params:
  - id: foo
    type: [default, {foo: str}, {foo: bar}] # has a default value so does not need to be provided
  - id: bar
  - type: [maybe, str] # optional parameter, can be omitted
  - id: env-vars
    type: [env-var] # a list of environment variables - no default or maybe, so must be provided
```

#### args
When a module calls another module, it passes values for parameters via the `args` key.

Values can be supplied in multiple different ways:
- Literal data: e.g. `foo`, `123`. `[false]`, `{foo: bar}` etc.
- References to parameters (as defined in `params`): `pt.param my-param`
- References to values: `pt.value my-value`.  Values are data (typically strings) that have been provided separately by the user.
- References to secrets: `pt.secret my-secret`. Secrets are sensitive data (typically strings) that have been provided separately by the user.
- Interpolated strings: strings that contain references to params, values or secrets, e.g. `http://{pt.param domain}:{pt.value port}/foo?api-key={pt.secret my-secret-key}`
- Code: TODO

Arg values can be any data but _MUST_ match the type spec of the corresponding param in the referenced module.

#### Example
```
module: the-module-were-calling  # module defined elsewhere, with params matching the args below
args:
    some-string-param: "hello world"      # plain string
    some-complex-param: [foo, {foo: bar}] # plain data
    some-param: pt.value foo              # reference to a value
    some-param-2: pt.secret foo           # reference to a secret
    some-param-3:
        foo: "interpolated string with a value: {pt.value foo}"
        bar: [pt.param bar, pt.secret baz] # data with inline references
```

#### Param type DSL

The param type DSL is how types are defined in Polytope.

Basic types:
- `str`: strings
- `bool`: `true` or `false`
- `int`: integers
- `num`: any number

Compound types:
- `[...]`: list of elements matching a given type (e.g. `[int]`, `[bool]`).
- `{...}`: map of named keys whose values match provided types (e.g. `{foo: int, bar: str}`)
- `[either, ...]`: union type (e.g. `[either, str, int]`, `[either, str, [str], int, {foo: int}]`)
- `[default, $type, $value]`: type with a default value (e.g. `[default, str, "my-default-value"]`)
- `[enum, ...]`: enum type (e.g. `[enum, 1, 2, "foo"]`)
- `[maybe, $type]`: marks a type as optional.
- `[regex, $regex]`: string type constrained to match the given regex.

There are also type aliases for commonly used types:
- `env-var`: equivalent to `{name: str, value: str}`
- `mount-source`: defined as `MountSourceSpec` in the definitions file. Intended for specifying data to be mounted containers. Examples:
  - `{type: host, path: /foo/bar}`: a path on the host machine to mount into the container. If a relative path like `some/folder` is provided, this is relative to the directory of the `polytope.yml` file. If a relative path with a leading `./`path like `./some/other/folder` is provided, it's relative to the current working directory.
  - `{type: string, data: my-string}`: literal string mounted as a file.
  - `{type: volume, scope: project, id: my-volume}`: a named volume. By default gets created if it doesn't already exist. Persisted across jobs ONLY IF `scope: project` is set.
- `service-spec`: a service specification. Must match `ServiceSpec` in the defiitions file. Keys:
  - `id`: the ID of the created service. Required.
  - `ports`: a list of named port mappings. `ServicePortsSpec` in the defiitions file. Each spec has the following keys:
    - `port`: the port on the container side.
    - `protocol`: the protocol being routed.
    - `expose-as`: the port on the host machine to which the port is mapped.

### Templates
`templates` holds a list of template specs. These specs must adhere to the `TemplateSpec` type in the definitions file.

The following keys are supported when defining a template:
- `id`: Uniquely identifies a template. May only contain '0–9', 'a–z', '_', and '-'. Required.
- `info`: Optional info string about the template.
- `params`: Parameter declarations for the template. Works the same way as for modules. Optional.
- `run`: A list of steps to run. Required. Explained below.

#### Steps
Steps may be provided in one of the following ways:

Plain module references, with no arguments:
```yaml
run:
  - my-module
  - polytope/hello-world
```

Or with arguments:
```yaml
run:
  - module: my-module
    args:
      foo: bar
      baz: 123
  - module: polytope/hello-world
    args:
      message: "Hello, world!"
```

By default, steps get their ID from the module ID. If you want to override this, you can specify the `id` key:
```yaml
run:
  - id: hello-world
    module: polytope/hello-world
    args:
      message: "Hello, world!"
  - id: aiya-ambar
    module: polytope/hello-world
    args:
      message: "Aiya Ambar!"
```

Steps run in parallel by default, but sequencing can be enforced by using `run-when`:
```yaml
run:
  - id: hello-world
    module: polytope/container
    args:
      image: ubuntu
      cmd: "echo Hello, world!"
  - id: hello-world
    module: polytope/hello-world
    args:
      message: "Hello world again!"
    run-when:
      after: hello-world # this step will run after the hello-world step, _INCLUDING THE ASSOCIATED CONTAINER_ completes
```
